<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Robert Edmonds' blog</title><link href="http://blog.mycre.ws/" rel="alternate"></link><link href="http://blog.mycre.ws/feeds/all.atom.xml" rel="self"></link><id>http://blog.mycre.ws/</id><updated>2015-03-01T22:36:32+00:00</updated><entry><title>Converting to --upstream-vcs-tag</title><link href="http://blog.mycre.ws/articles/converting-to-upstream-vcs-tag/" rel="alternate"></link><updated>2015-03-01T22:36:32+00:00</updated><author><name>Robert Edmonds</name></author><id>tag:blog.mycre.ws,2015-03-01:articles/converting-to-upstream-vcs-tag/</id><summary type="html">&lt;p&gt;Recently, the Google protobuf developers &lt;a href="https://groups.google.com/d/msg/protobuf/3qvNnYo8-SM/GSMYGGBNXfoJ"&gt;announced&lt;/a&gt; a migration of their
project's source code from an &lt;a href="https://code.google.com/p/protobuf/source/browse/"&gt;svn repository&lt;/a&gt; to a &lt;a href="https://github.com/google/protobuf"&gt;git repository&lt;/a&gt;. Up until
this point, the &lt;a href="http://anonscm.debian.org/cgit/collab-maint/protobuf.git"&gt;Debian protobuf package repository&lt;/a&gt; had only tracked upstream
development by embedding upstream release tarballs using &lt;code&gt;gbp import-orig&lt;/code&gt; with
&lt;code&gt;pristine-tar&lt;/code&gt;. It would be nice to smoothly migrate the packaging repository to
additionally make use of the &lt;code&gt;--upstream-vcs-tag&lt;/code&gt; option to &lt;code&gt;gbp import-orig&lt;/code&gt;,
the advantages of which have been &lt;a href="http://www.eyrie.org/~eagle/journal/2013-04/001.html"&gt;well described by Russ Allbery&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This turned out to be harder than expected, so for reference I documented the
steps I took below. Note that this packaging repository uses the default &lt;code&gt;gbp
import-orig&lt;/code&gt; repository layout, where upstream sources are placed on a branch
named &lt;code&gt;upstream&lt;/code&gt;, and the Debian branch is named &lt;code&gt;master&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Add an &lt;code&gt;upstream&lt;/code&gt; remote configured to track the upstream repository's &lt;code&gt;master&lt;/code&gt;
branch and tags.&lt;/p&gt;
&lt;pre&gt;&lt;code class="boxed"&gt;$ git remote add --tags --track master upstream https://github.com/google/protobuf.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;upstream&lt;/code&gt; remote shouldn't be confused with our &lt;code&gt;upstream&lt;/code&gt; branch. Note
that git-remotes are local to the repository, so the &lt;code&gt;upstream&lt;/code&gt; remote should
probably be documented in the &lt;code&gt;debian/README.source&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Fetch the upstream branch and tags.&lt;/p&gt;
&lt;pre&gt;&lt;code class="boxed"&gt;$ git fetch upstream
warning: no common commits
remote: Counting objects: 5210, done.
remote: Compressing objects: 100% (861/861), done.
remote: Total 5210 (delta 3869), reused 5194 (delta 3855)
Receiving objects: 100% (5210/5210), 3.57 MiB | 1.43 MiB/s, done.
Resolving deltas: 100% (3869/3869), done.
From https://github.com/google/protobuf
 * [new branch]      master     -&amp;gt; upstream/master
 * [new tag]         v2.6.0     -&amp;gt; v2.6.0
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have a git-remote &lt;code&gt;upstream&lt;/code&gt;, a remote-tracking branch &lt;code&gt;upstream/master&lt;/code&gt;
which corresponds to the &lt;code&gt;master&lt;/code&gt; branch that upstream makes releases from, and
a release tag &lt;code&gt;v2.6.0&lt;/code&gt;. Note that the remote-tracking branch &lt;code&gt;upstream/master&lt;/code&gt;
shouldn't be confused with our &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;
&lt;p&gt;Up until this point, our &lt;code&gt;upstream&lt;/code&gt; branch has been synthetically generated by
importing upstream's release tarballs with &lt;code&gt;gbp import-orig&lt;/code&gt;. We need to merge
this synthetic history with &lt;code&gt;upstream/master&lt;/code&gt;. Unfortunately, I couldn't find a
way to do this without using a temporary branch.&lt;/p&gt;
&lt;pre&gt;&lt;code class="boxed"&gt;$ git checkout -b tmp upstream/master
Branch tmp set up to track remote branch master from upstream.
Switched to a new branch 'tmp'
$ git merge -s ours -m \
  &amp;quot;Merge the original 'upstream' branch with upstream's new master branch&amp;quot; upstream
Merge made by the 'ours' strategy.
$ git checkout upstream
Switched to branch 'upstream'
Your branch is up-to-date with 'origin/upstream'.
$ git merge --ff-only tmp
Updating 7ed940b..9ba221e
Fast-forward
 CHANGES.txt                                                     |    49 +-
 COPYING.txt =&amp;gt; LICENSE                                          |     0
 Makefile.am                                                     |    64 +-
 Makefile.in                                                     |  1041 --
 README.txt =&amp;gt; README.md                                         |    49 +-
[...many more lines...]
$ git branch -D tmp
Deleted branch tmp (was 5f18f02).
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are now an additional 400 or so commits on our &lt;code&gt;upstream&lt;/code&gt; branch,
corresponding to the new git repository history published by upstream.&lt;/p&gt;
&lt;p&gt;Import the 2.6.0 release tarball against the upstream &lt;code&gt;v2.6.0&lt;/code&gt; tag, using the
&lt;code&gt;--upstream-vcs-tag&lt;/code&gt; option.&lt;/p&gt;
&lt;pre&gt;&lt;code class="boxed"&gt;$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.
$ gbp import-orig -u 2.6.0 --upstream-vcs-tag=v2.6.0 ~/debian/tarballs/protobuf_2.6.0.orig.tar.gz
gbp:info: Importing '/home/edmonds/debian/tarballs/protobuf_2.6.0.orig.tar.gz' to branch 'upstream'...
gbp:info: Source package is protobuf
gbp:info: Upstream version is 2.6.0
pristine-tar: committed protobuf_2.6.0.orig.tar.gz.delta to branch pristine-tar
gbp:info: Merging to 'master'
gbp:info: Successfully imported version 2.6.0 of /home/edmonds/debian/tarballs/protobuf_2.6.0.orig.tar.gz
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;upstream&lt;/code&gt; branch now contains a mixture of the original series of release
tarball content imported by plain &lt;code&gt;gbp import-orig&lt;/code&gt; and the &lt;code&gt;upstream/master&lt;/code&gt;
branch as published by upstream.&lt;/p&gt;
&lt;p&gt;Updating the Debian packaging repository when new upstream releases occur only
requires a &lt;code&gt;git fetch&lt;/code&gt; to pull down upstream's updated git history and release
tag and using the &lt;code&gt;--upstream-vcs-tag&lt;/code&gt; option when importing the release
tarball with &lt;code&gt;gbp import-orig&lt;/code&gt;.&lt;/p&gt;</summary></entry><entry><title>BIND and GCC 4.9</title><link href="http://blog.mycre.ws/articles/bind-and-gcc-49/" rel="alternate"></link><updated>2014-06-06T02:19:08+00:00</updated><author><name>Robert Edmonds</name></author><id>tag:blog.mycre.ws,2014-06-06:articles/bind-and-gcc-49/</id><summary type="html">&lt;p&gt;ISC has issued an &lt;a href="https://kb.isc.org/article/AA-01167"&gt;operational notification&lt;/a&gt; advising the use of the
&lt;code&gt;-fno-delete-null-pointer-checks&lt;/code&gt; flag when compiling current versions of BIND
with GCC 4.9:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Beginning with GCC 4.9.0, code optimization in GCC now includes (by default)
an optimization which is intended to eliminate unnecessary null pointer
comparisons in compiled code.  Unfortunately this optimization removes checks
which are necessary in BIND and the demonstrated effect is to cause
unpredictable assertion failures during execution of named, resulting in
termination of the server process.&lt;/p&gt;
&lt;p&gt;Future versions of BIND will be modified so that the optimizer does not
incorrectly remove necessary checks when building from source, and until those
versions are available multiple immediate workarounds are available.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;According to the &lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"&gt;GCC documentation&lt;/a&gt;, &lt;code&gt;-fdelete-null-pointer-checks&lt;/code&gt; performs
the following optimization, and is enabled by default even when compiling with
&lt;code&gt;-O0&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Assume that programs cannot safely dereference null pointers, and that no code
or data element resides there. This enables simple constant folding
optimizations at all optimization levels. In addition, other optimization
passes in GCC use this flag to control global dataflow analyses that eliminate
useless checks for null pointers; these assume that if a pointer is checked
after it has already been dereferenced, it cannot be null.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This optimization &lt;a href="http://www.gnu.org/software/gcc/news/null.html"&gt;dates back to 1999&lt;/a&gt; but it recently &lt;a href="https://gcc.gnu.org/gcc-4.9/porting_to.html"&gt;became more aggressive&lt;/a&gt;
in the GCC 4.9 release:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GCC might now optimize away the null pointer check in code like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int copy (int* dest, int* src, size_t nbytes) {
  memmove (dest, src, nbytes);
  if (src != NULL)
    return *src;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The pointers passed to &lt;code&gt;memmove&lt;/code&gt; (and similar functions in &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;) must
be non-null even when &lt;code&gt;nbytes==0&lt;/code&gt;, so GCC can use that information to remove
the check after the &lt;code&gt;memmove&lt;/code&gt; call. Calling &lt;code&gt;copy(p, NULL, 0)&lt;/code&gt; can therefore
deference a null pointer and crash.&lt;/p&gt;
&lt;p&gt;The example above needs to be fixed to avoid the invalid &lt;code&gt;memmove&lt;/code&gt; call, for
example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (nbytes != 0)
  memmove (dest, src, nbytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;It's interesting that the ISC operational advisory labels this an "incorrect"
optimization. I wonder if this is a similar case to the &lt;a href="http://lwn.net/Articles/414467/"&gt;Glibc optimization&lt;/a&gt;
which exposed incorrect usage of &lt;code&gt;memcpy()&lt;/code&gt; in many applications, &lt;a href="https://kb.isc.org/article/AA-01085"&gt;including
BIND&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately, few users should be affected by this bug, since GCC 4.9 is fairly
new. (The upcoming &lt;a href="http://fedoraproject.org/wiki/Releases/21/ChangeSet#GCC49"&gt;Fedora 21 release&lt;/a&gt; will probably be the first mainstream
distribution to ship with GCC 4.9 as the default compiler.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: Debian bug &lt;a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=750760"&gt;#750760&lt;/a&gt; filed.&lt;/p&gt;</summary></entry></feed>